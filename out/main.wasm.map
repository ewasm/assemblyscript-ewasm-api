{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","main.ts"],"names":[],"mappings":"qVCgBE,AAAI,IACF,AAAI,EAAO,SAAa,EACxB,AAAU,IACV,AAAa,AAAC,EAAM,GAAO,GAAW,AAAC,QACvC,AAAkB,IAClB,AAAI,EAAS,EAAsB,MACjC,AAAkB,AAAC,AAAC,EAAS,GAAM,KAAU,AAAC,QAAY,KAC1D,AAAkB,AAAI,IAAa,YACnC,AAAI,AAAY,IAAe,KAAG,AAC5B,AAAY,IAAe,KAAG,IAKtC,AAAS,IACF,IAEF,OCMP,AAAI,EAA+B,KACjC,AAAgB,EAAG,KAErB,AAAuB,AAAgB,MACvC,AAAsB,EAAY,EAAG,IACrC,AAAuB,AAAgB,MACvC,AAAqB,EAAY,IACjC,AAAkB,EAAY,IAC9B,AAAkB,EAAY,IAC9B,AAAgB,EAAY,SAI5B,AAAI,EAA+B,KACjC,AAAgB,EAAG,KAErB,AAAsB,AAAgB,MACtC,AAAmB,IACnB,AAAyB,AAAgB,MACzC,AAAsB,EAAc,EAAG,IACvC,AAAqB,AAAgB,MACrC,AAAsB,EAAU,EAAI,IACpC,AAAkB,EAAU,IAC5B,AAAuB,AAAgB,MACvC,AAA0B,AAAgB,MAC1C,AAAqB,EAAW,IAChC,AAAqB,EAAc,IACnC,AAAkB,EAAW,IAC7B,AAAkB,EAAc,IAChC,AAAkB,EAAkB,IACpC,AAAkB,EAAqB,IAEvC,AAAoB,AAAU,OAC9B,AAAuB,AAAU,OACjC,AAAY,AAAU,OAEtB,AAAI,EAAgB,KAClB,AAAgB,EAAG,KAErB,AAAW,EAAkB,EAAgB,MAC7C,AAAW,EAAqB,EAAmB,MACnD,AAAsB,EAAW,IACjC,AAAsB,EAAc,UA7DpC,AAAI,EAA6B,KAC/B,AAAgB,EAAG,KAErB,AAAwB,AAAgB,MACxC,AAAsB,EAAa,EAAG,IACtC,AAAqB,AAAU,OAC/B,QAAO,MACA,WAGA,YAFH,EACA,GAEA,EACA,GAEA,AAAgB,EAAG,QDvBA,AAAC,EAAY,GAAW,AAAC,QAC9B","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (size) {\n    if (size > MAX_SIZE_32) unreachable();\n    let ptr = offset;\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n    let pagesBefore = current_memory();\n    if (newPtr > <usize>pagesBefore << 16) {\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n    }\n    offset = newPtr;\n    return ptr;\n  }\n  return 0;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  offset = startOffset;\n}\n","import 'allocator/arena';\n\n// ewasm imports\ndeclare function ethereum_return(dataOffset: i32, length: i32): void;\ndeclare function ethereum_revert(dataOffset: i32, length: i32): void;\ndeclare function ethereum_callDataCopy(resultOffset: i32, dataOffset: i32, length: i32): void;\ndeclare function ethereum_getCallDataSize(): i32;\ndeclare function ethereum_getCaller(dataOffset: i32): void;\ndeclare function ethereum_storageStore(pathOffset: i32, valueOffset: i32): void;\ndeclare function ethereum_storageLoad(pathOffset: i32, resultOffset: i32): void;\ndeclare function debug_printMemHex(dataOffset: i32, length: i32): void;\n\n// TODO: need to implement a nice wrapper over the native functions which use native types and handles the memory.\n\n// ewasm main function\nexport function main(): void {\n  // assume the memory is already expanded..\n  // ethereum_return(0, ethereum_callDataSize())\n\n  // Make sure we have enough args\n  if (ethereum_getCallDataSize() < 4)\n    ethereum_revert(0, 0);\n\n  var ptrSelector : i32 = allocate_memory(4);\n  ethereum_callDataCopy(ptrSelector, 0, 4);\n  var selector : i32 = load<i32>(ptrSelector);\n  switch(selector) {\n    case 0x9993021a:\n      do_balance();\n      break;\n    case 0x5d359fbd:\n      do_transfer();\n      break;\n    default:\n      ethereum_revert(0, 0);\n  }\n}\n\nfunction do_balance(): void {\n  if (ethereum_getCallDataSize() !== 24)\n    ethereum_revert(0, 0);\n\n  var ptrAddress : i32 = allocate_memory(20);\n  ethereum_callDataCopy(ptrAddress, 4, 20);\n  var ptrBalance : i32 = allocate_memory(32);\n  ethereum_storageLoad(ptrAddress, ptrBalance);\n  debug_printMemHex(ptrAddress, 32);\n  debug_printMemHex(ptrBalance, 32);\n  ethereum_return(ptrBalance, 32);\n}\n\nfunction do_transfer(): void {\n  if (ethereum_getCallDataSize() !== 32)\n    ethereum_revert(0, 0);\n\n  var ptrSender : i32 = allocate_memory(32);\n  ethereum_getCaller(ptrSender);\n  var ptrRecipient : i32 = allocate_memory(32);\n  ethereum_callDataCopy(ptrRecipient, 4, 20);\n  var ptrValue : i32 = allocate_memory(32);\n  ethereum_callDataCopy(ptrValue, 24, 8);\n  debug_printMemHex(ptrValue, 32);\n  var ptrSenderBalance = allocate_memory(32);\n  var ptrRecipientBalance = allocate_memory(32);\n  ethereum_storageLoad(ptrSender, ptrSenderBalance);\n  ethereum_storageLoad(ptrRecipient, ptrRecipientBalance);\n  debug_printMemHex(ptrSender, 32);\n  debug_printMemHex(ptrRecipient, 32);\n  debug_printMemHex(ptrSenderBalance, 32);\n  debug_printMemHex(ptrRecipientBalance, 32);\n\n  var senderBalance = load<i32>(ptrSenderBalance);\n  var recipientBalance = load<i32>(ptrRecipientBalance);\n  var value = load<i32>(ptrValue);\n  \n  if (senderBalance < value)\n    ethereum_revert(0, 0);\n\n  store<i32>(ptrSenderBalance, senderBalance - value);\n  store<i32>(ptrRecipientBalance, recipientBalance + value);\n  ethereum_storageStore(ptrSender, ptrSenderBalance);\n  ethereum_storageStore(ptrRecipient, ptrRecipientBalance);\n}\n\n"]}
